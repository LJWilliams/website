{% extends "_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python and Images" />
{% endblock file_metadata %}

{% block content %}

<p>
  Valerie Visual is studying how people visualize and recall color.
  For one of her experiments,
  she wants to cut a photograph of faces into rectangular pieces
  and time how long it takes subjects to reassemble those pieces
  after they have been recolored in different ways.
</p>

<p>
  If Valerie only wanted to use one or two images,
  the simplest way to create the puzzles she needs might be
  to use a tool like Photoshop.
  However,
  she wants to give each subject several dozen puzzles to solve
  (since each one typically only takes a few seconds to assemble).
  Since she doesn't want to spend hours cutting and coloring images,
  she wants to write a small program to do the job for her.
  To do that,
  she's going to have to learn how to program,
  and that's what the next couple of chapters are about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<p>
  Our programs will use a library for manipulating images
  that was specifically written for novices.
  Many of the things we will do in five or ten lines
  can actually be done in a single line by an experienced programmer,
  but since our goal is to show you how to write programs of your own,
  we will leave the training wheels on for now.
</p>

<section id="s:basic">

  <h2>Basic Operations</h2>

  <div class="understand" id="u:basic">
    <h3>Understand:</h3>
    <ul>
      <li>How to use the Python interpreter interactively.</li>
      <li>How to do basic arithmetic.</li>
      <li>How to assign values to variables.</li>
    </ul>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so let's run the Python interpreter
    and type in the following:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <p class="continue">
    The <code>&gt;&gt;&gt;</code> <a href="glossary.html#prompt">prompt</a>
    is the interpreter's way of telling us that it's waiting for input,
    like the <code>$</code> prompt in <a href="shell.html">the shell</a>.
    When we enter 1+1,
    Python does the calculation we've asked for
    and prints the result.
  </p>

  <p>
    Now type this:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except another prompt).
    Instead,
    as <a href="#f:first_variable">Figure 1</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print x</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_variable">
    <img src="img/python/first_variable.png" alt="Our First Variable" />
  </figure>

  <div class="box">

    <h3>Statements vs. Expressions</h3>

    <p>
      Python is a fairly relaxed language,
      but there are still some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

  </div>

  <p>
    We can now use that variable's value in calculations:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print x * 2</span>
4
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">y = x * 2</span>
&gt;&gt;&gt; <span class="in">print y</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 10</span>
&gt;&gt;&gt; <span class="in">print x</span>
10
</pre>

  <p class="continue">
    As <a href="#f:assign_new_value">Figure XXX</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="img/python/assign_new_value.png" alt="Assigning a New Value" />
  </figure>

  <p>
    Here's a more complex calculation:
  </p>

<pre src="src/python/fahrenheit_to_kelvin_unreadable.py">
&gt;&gt;&gt; <span class="in">x = 98.6</span>
&gt;&gt;&gt; <span class="in">y = (x - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print y</span>
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre src="src/python/fahrenheit_to_kelvin.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a href="#f:first_memory_model">Figure XXX</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="img/python/first_memory_model.png" alt="First Memory Model" />
  </figure>

  <p>
    Like every program,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    this one is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the real bottleneck in scientific computing is usually not
    how fast the program runs,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>.
  </p>

  <div class="box">

    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">double_temp = temp_celsius * 2</span>
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">Traceback (most recent call last):
  File "&lt;undefined-variable.py&gt;", line 1, in &lt;module&gt;
NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes:
      if we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15</span>
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>

  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <p>
    Finally,
    this first program also shows how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
    We have to use parentheses here because
    (also as in arithmetic)
    multiplication takes precedence over addition:
    the expression <code>2*3+5</code> means,
    "Multiply two by three, then add five,"
    rather than,
    "Add three and five, then multiple by two."
    If we want the latter,
    we have to write <code>2*(3+5)</code>.
  </p>

  <div class="box">

    <h3>Repeating Commands</h3>

    <p>
      Just as we could repeat previous commands in the shell
      by using the <a href="shell.html#a:repeat">up arrow</a>,
      so too can we repeat commands in the Python interpreter.
      And while the standard interpreter doesn't have an equivalent
      of the shell's <code>history</code> command,
      more advanced shells like IPython do
      (along with much more).
    </p>

  </div>

  <div class="keypoints" id="k:basic">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display values.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li idea="perf">Use meaningful, descriptive names for variables.</li>
    </ul>
  </div>

</section>

<section id="s:types">

  <h2>Types</h2>

  <div class="understand" id="u:types">
    <h3>Understand:</h3>
    <ul>
      <li>What data types are.</li>
      <li>The differences between integers, floating-point numbers, and strings.</li>
      <li>How to call a function.</li>
      <li>Why computers shouldn't guess what people want.</li>
    </ul>
  </div>

  <p>
    Let's take another look at our program:
  </p>

<pre src="src/python/fahrenheit_to_kelvin.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre src="src/python/fahrenheit_to_kelvin_int.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">5/9</span>
<span class="out">0</span>
</pre>

  <p>
    The problem is that integers and floating point numbers
    (or <a href="glossary.html#float">floats</a>)
    are different things to a computer.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer (with no fractional part).
    When it divides one integer by another,
    it throws away the remainder.
    If a number contains a decimal point,
    though,
    Python stores it as a float.
    When it does division (or any other kind of arithmetic),
    the result is a float if either of the values involved is a float:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">10 / 3</span>
<span class="out">3</span>
&gt;&gt;&gt; <span class="in">10.0 / 3</span>
<span class="out">3.3333333333333335</span>
</pre>

  <p class="continue">
    This makes sense,
    but only if you understand how the chips inside computers work.
    Version 3 of Python changed the rules for division
    so that it returns fractional numbers whenever it needs to.
    However,
    we're using Python 2.7 in this course,
    so 10/3 is 3 until further notice.
  </p>

  <p>
    Every value in a program has a specific <a href="glossary.html#type">type</a>
    which determines how it behaves
    and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>


<pre>
&gt;&gt;&gt; <span class="in">type(12)</span>
<span class="out">&lt;type 'int&gt;</span>
&gt;&gt;&gt; <span class="in">type(12.0)</span>
<span class="out">&lt;type 'float&gt;</span>
</pre>

  <p>
    Integers and floating-point numbers are two common types;
    another is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as they match at the beginning and end):
  </p>

<pre src="src/python/simple_string.py">
&gt;&gt;&gt; <span class="in">name = "Alan Turing"</span>
&gt;&gt;&gt; <span class="in">born = 'June 23, 1912'</span>
&gt;&gt;&gt; <span class="in">print name, born</span>
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" strings:
  </p>

<pre src="src/python/simple_string.py">
&gt;&gt;&gt; <span class="in">full = name + " (" + born + ")"</span>
&gt;&gt;&gt; <span class="in">print full</span>
<span class="out">Alan Turing (June 23, 1912)</span>
</pre>

  <p>
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre src="src/python/add_numbers_strings.py">
&gt;&gt;&gt; <span class="in">print 2 + "three"</span>
<span class="err">Traceback (most recent call last):
  File "add-numbers-strings.py", line 1, in &lt;module&gt;
    print 2 + "three"
TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The string "2three" would be a reasonable result in this case,
    but it's not so clear what <code>2+"3"</code> should do:
    should it produce the integer 5 or the string <code>"23"</code>?
    Rather than guessing at the programmer's intentions,
    Python expects some guidance:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 2 + int("3")</span>
<span class="out">5</span>
&gt;&gt;&gt; <span class="in">print str(2) + "3"</span>
<span class="out">23</span>
</pre>

  <p>
    <code>int</code> and <code>str</code> are two more built-in functions
    which convert values to particular types.
    We'll look at functions in much more detail
    in <a href="funclib.html">the next chapter</a>.
  </p>

  <div class="keypoints" id="k:types">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both arguments must be <code>float</code> to get a <code>float</code> result.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li idea="meaning">Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables do not have types, but values do.</li>
    </ul>
  </div>

</section>

<section id="s:openshow">

  <h2>Displaying Images</h2>

  <div class="understand" id="u:openshow">
    <h3>Understand:</h3>
    <ul>
      <li>How to open and display images.</li>
      <li>What a library is.</li>
      <li>Why programs are built out of libraries.</li>
      <li>What a method is and how to call one.</li>
    </ul>
  </div>

  <p>
    Now that we can do basic arithmetic,
    let's look at some images:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">from skimage import novice</span>
&gt;&gt;&gt; <span class="in">flower = novice.open('flower.jpg')</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <p>
    This three-line program introduces one new idea per line.
    The first statement asks Python to find a library called <code>skimage</code>
    (the SciKit image processing library)
    and load something called <code>novice</code> from it.
    The second statement asks <code>novice</code> to open a file called <code>flower.jpg</code>;
    the result of that operation is assigned to a variable called <code>flower</code>.
    The final statement asks the thing <code>flower</code> now points at to display itself.
    If all has gone well,
    this should show a picture of the world's cutest child
    (<a href="#f:flower">Figure XXX</a>).
  </p>

  <figure id="f:flower">
    <img src="img/pymedia/flower.jpg" alt="The World's Cutest Child" />
  </figure>

  <p>
    A <a href="glossary.html#library">library</a>
    (or <a href="glossary.html#module">module</a>&mdash;for our purposes, the terms mean the same thing)
    is one of the most important ideas in all of programming.
    No language could possibly contain every single feature that everyone might ever want.
    Even if it did,
    people's needs evolve over time,
    so an "all inclusive" approach would mean constantly releasing new versions of the language.
    Instead,
    every programming language provides a way for people to define new tools themselves,
    and then load those tools into other programs.
    In this case,
    someone wrote an image processing library called <code>skimage</code>,
    and someone else (a graduate student named Mike Hansen)
    added a sub-library to it called <code>novice</code>
    to provide an easy-to-use interface for people who are just learning to program.
    When we write:
  </p>

<pre>
from skimage import novice
</pre>

  <p class="continue">
    we are asking Python to find the <code>skimage</code> library,
    search inside it for <code>novice</code>,
    and load that into memory for use.
  </p>

  <p>
    To get at the things <code>novice</code> contains,
    we then refer to them as <code>novice.<em>something</em></code>.
    This <a href="glossary.html#dotted-notation">dotted notation</a> was invented
    to deal with the fact that people often choose the same names for different things.
    For example,
    <code>skimage.novice</code>'s <code>open</code> looks for a file on disk and opens that,
    but another library called <code>web</code> might provide something called <code>open</code>
    that opened a connection to a web site.
    Using <code>thing.subthing.subsubthing</code> to name things
    is exactly like using the genus and species names to identify particular organisms.
  </p>

  <div class="box">

    <h3>There's More Than One Way to Name It</h3>

    <p>
      You may have noticed above that we referred to <code>novice</code> as <code>skimage.novice</code>.
      If we want to do this in our program,
      we could rewrite it as:
    </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

    <p class="continue">
      which performs exactly the same operations as the original.
      What we <em>can't</em> do is:
    </p>

<pre>
import skimage
flower = novice.open('flower.jpg')
</pre>

    <p class="continue">
      or:
    </p>

<pre>
from skimage import novice
flower = skimage.novice.open('flower.jpg')
</pre>

    <p class="continue">
      The first (<code>import skimage</code>) doesn't define anything in our program called <code>novice</code>;
      it only defines <code>skimage</code>.
      The second does the reverse:
      it defines <code>novice</code> <em>without</em> defining <code>skimage</code>.
    </p>

    <p>
      And yes,
      we could do this:
    </p>

<pre>
from skimage.novice import open
flower = open('flower.jpg')
</pre>

    <p class="continue">
      but it would be a very bad idea.
      Python actually has a built-in function called <code>open</code>
      that opens arbitrary files so that the bytes in them can be read.
      If we run the code shown immediately above,
      that built-in function will be replaced by
      <code>skimage.novice</code>'s <code>open</code>,
      which will probably break most programs
      (since most files aren't actually images).
    </p>

  </div>

  <p>
    With that out of the way,
    the second statement in:
  </p>

<pre>
from skimage import novice
<span class="highlight">flower = novice.open('flower.jpg')</span>
flower.show()
</pre>

  <p class="continue">
    should be pretty easy to understand.
    It's a function call:
    it just happens that the function being called is contained in the <code>novice</code> library.
    Similarly,
    the expression <code>flower.show()</code> is another call
    that asks whatever the variable <code>flower</code> points at
    to call the <code>show</code> function it contains.
  </p>

  <p>
    Another way to think about this program is shown in <a href="#f:memory_model_image_display">Figure XXX</a>.
    After the first statement,
    Python has created a variable called <code>novice</code>
    that refers to <code>skimage</code>'s <code>novice</code> module.
    After the second statement,
    that module has loaded bytes from an image file on disk into memory,
    wrapped an object around them,
    and creatd a variable called <code>flower</code> to refer to that object.
  </p>

  <figure id="f:memory_model_image_display">
    <img src="img/pymedia/memory_model_image_display.jpg" alt="Memory Model of Image Display Program" />
  </figure>

  <div class="keypoints" id="k:openshow">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">Write summary</li>
      <li class="fixme">Explain scope of imports: program session</li>
    </ul>
  </div>

</section>

<section id="s:program">

  <h2>Creating Programs</h2>

  <div class="understand" id="u:program">
    <h3>Understand:</h3>
    <ul>
      <li>How to create and run programs.</li>
    </ul>
  </div>

  <p>
    Typing in commands over and over again is tedious and error-prone.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre src="src/python/greeting.py">
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and then save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    Of course,
    we can do this with our image display program as well:
  </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

  <p>
    When we save this as <code>showflower.py</code>,
    and run it as:
  </p>

<pre>
$ <span class="in">python showflower.py</span>
</pre>

  <p class="continue">
    it displays our picture.
    <span class="fixme">explain how to kill it</span>
  </p>

  <p>
    When the Python interpreter executes a file,
    it runs the commands in that file
    just as if they had been typed in interactively.
    It doesn't wait until the whole file has been read
    to start executing;
    instead,
    as the example below shows,
    it runs each command as soon as it can:
  </p>

    <!-- JK: I think what was intended here was for the first 3 lines to 
         replace the existing 3 lines in greeting.py, then 'python greeting.py' 
         was to be run from the shell? If so, having the first 3 new lines in a 
         separate blue box might be more clear. Also, the text below currently
         references a.py. -->

<pre src="src/python/executing_file.py">
print "before"
1/0
print "after"
<span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "a.py", line 2, in &lt;module&gt;
    1/0
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <p class="continue">
    Note that this can lead to some confusing output.
    For example,
    if we change the example above to:
  </p>

<pre>
print "before", 1/0, "after"
</pre>

  <p class="continue">
    then the output is:
  </p>

<pre><span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <div class="keypoints" id="k:program">
    <h3>Summary</h3>
    <ul>
      <li>Store programs in files whose names end in <code>.py</code> and run them with <code>python <em>name.py</em></code>.</li>
    </ul>
  </div>

</section>

<section id="s:properties">

  <h2>Image Properties</h2>

  <div class="understand" id="u:properties">
    <h3>Understand:</h3>
    <ul>
      <li>How to inspect and modify the properties of images.</li>
      <li>How to save images to files.</li>
    </ul>
  </div>

  <p>
    Let's take another look at the world's cutest child:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">from skimage import novice</span>
&gt;&gt;&gt; <span class="in">flower = novice.open('flower.jpg')</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <p class="continue">
    What else can we do besides display this image?
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print flower.format</span>
<span class="out">JPEG</span>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/flower.jpg</span>
&gt;&gt;&gt; <span class="in">print flower.height</span>
<span class="out">180</span>
&gt;&gt;&gt; <span class="in">print flower.width</span>
<span class="out">240</span>
</pre>

  <p>
    As this example shows,
    a picture object has <a href="glossary.html#property">properties</a>:
    its format (JPEG, PNG, and so on),
    the path to the file it was loaded from,
    and its height and width in pixels.
    Some of these are unchangeable,
    so that we can confuse our program
    by fooling it into thinking that a JPEG image is actually stored as a PNG,
    or that it was loaded from a different file than it actually was:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.format = 'PNG'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute</span>
&gt;&gt;&gt; <span class="in">flower.path = '/profiles/alan-turing.jpg'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
AttributeError: can't set attribute</span>
</pre>

  <p>
    Others,
    however,
    are changeable.
    For example,
    we can squish the image by altering its height
    (<a href="#f:flower_squished">Figure XXX</a>).
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.height = 90</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <figure id="f:flower_squished">
    <img src="img/pymedia/flower_squished.jpg" alt="Squishing a Picture" />
  </figure>

  <p>
    We can now save this picture to a new file if we want:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.save('squished.jpg')</span>
</pre>

  <p>
    When we do this,
    the object's <code>path</code> property is automatically updated:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.jpg</span>
</pre>

  <p>
    And if we want to change its format,
    we can do that by saving it to a file with the appropriate suffix:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.save('squished.<span class="highlight">png</span>')</span>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.png</span>
</pre>

  <p>
    Now,
    suppose we want to create a thumbnail of a picture to put on a web page.
    We want the thumbnail to be exactly 30 pixels wide to fit into a table,
    and we want its height scaled proportionally.
    Here's what we could do:
  </p>

<pre>
from skimage import novice
picture = novice.open('mac.jpg')
new_height = picture.height * 30 / picture.width
picture.height = new_height
picture.width = 30
picture.save('thumb-mac.jpg')
</pre>

</section>

<section id="s:color">

  <h2>Colors</h2>

  <div class="understand" id="u:color">
    <h3>Understand:</h3>
    <ul>
      <li>How computers represent colors.</li>
      <li>How to create images from scratch.</li>
      <li>How to change the color of every pixel in an image.</li>
    </ul>
  </div>

  <p>
    Before we go any further,
    we need to talk about how computers represent colors.
    The most common scheme,
    called "RGB",
    stores red, green, and blue values for each pixel in an image.
    This is an additive color model:
    the color we see is the sum of the individual color values,
    each of which can range between 0 and 255.
    (Why 255?
    Because computer memory is organized into 8-bit bytes,
    and 255 (11111111 in base 2) is the largest integer that can be represented in one byte.)
  </p>

  <p>
    In RGB,
    black is (0, 0, 0), i.e., nothing of any color.
    White is the maximum value of all three colors, or (255, 255, 255).
    We can think of this color model is as a cube
    (<a href="#f:color_cube">Figure XXX</a>).:
    the three axes represent the primary colors,
    while secondary colors are combinations of maximum values,
    and each actual color is a coordinate in this cube.
  </p>

  <figure id="f:color_cube">
    <img src="img/pymedia/color_cube.png" alt="A Color Cube" />
  </figure>

  <p>
    Let's have a look at how the three primary colors actually appear:
  </p>

<pre>
from skimage import novice
all_red = novice.new((200, 200), (255, 0, 0))
all_red.show()
all_green = novice.new((200, 200), (0, 255, 0))
all_green.show()
all_blue = novice.new((200, 200), (0, 0, 255))
all_blue.show()
</pre>

  <figure id="f:primary_colors">
    <img src="img/pymedia/primary_colors.png" alt="Primary Colors" />
  </figure>

  <p>
    This program produces the three images shown in <a href="#f:primary_colors">Figure XXX</a> in turn.
    The most important thing about it, though,
    is actually where the parentheses are.
    Just as in math,
    programs often use parentheses to group values together.
    Here,
    we are using them to group (200, 200) together as the size of the image in pixels,
    and (255, 0, 0) together as an RGB color value.
    The designer of this library <em>could</em> have let us pass these values without the grouping,
    as in:
  </p>

<pre>
novice.new(200, 200, 255, 0, 0)
</pre>

  <p class="continue">
    but as the number of values grows,
    it quickly becomes difficult to keep track of which ones belong together.
    A group of parenthesized values is called <a href="glossary.html#tuple">tuple</a>;
    we can assign tuples to variables,
    and then use those variables in our programs to make our code easier to read:
  </p>

<pre>
from skimage import novice
<span class="highlight">image_size = (200, 200)</span>
all_red = novice.new(<span class="highlight">image_size</span>, (255, 0, 0))
all_red.show()
all_green = novice.new(<span class="highlight">image_size</span>, (0, 255, 0))
all_green.show()
all_blue = novice.new(<span class="highlight">image_size</span>, (0, 0, 255))
all_blue.show()
</pre>

  <p>
    One nice side effect of this is that it also makes our programs easier to change.
    If we want our images to be 300 pixels across instead of 200,
    we only have to change the value of <code>image_size</code>,
    and everything else just works.
    This is a basic rule of good program design:
    any given piece of information should be stored in one place, once,
    so that any change requires only one change in one place.
  </p>

  <p>
    <code>skimage.novice</code> lets us change image colors using properties as well.
    If we don't initially specify a color for an image,
    the image's pixels are all set to black:
  </p>

<pre>
from skimage import novice
image_size = (200, 200)
picture = novice.new(image_size)
</pre>

  <p>
    We can now change the red, green, or blue values of all its pixels like this
    (<a href="#f:color_properties">Figure XXX</a>):
  </p>

<pre>
picture.red   = 128
picture.green = 192
picture.blue  = 255
picture.show()
</pre>

  <figure id="f:color_properties">
    <img src="img/pymedia/color_properties.png" alt="Color Properties" />
  </figure>

</section>

<section id="s:pixels">

  <h2>Manipulating Pixels</h2>

  <p>
    Changing the color of the entire image at once is useful for creating backgrounds,
    but most pictures have more detail than that.
    If we want to change the color of a single pixel,
    we need a way to refer to it.
    In Python and most other languages,
    we do that by providing an <a href="glossary.html#index">index</a>,
    which is just the coordinates of the pixel we want to access.
    To create a red image with a single white pixel in the lower-left corner,
    we would do this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
block.show()
</pre>

  <p>
    The first thing to notice about this example is that the lower-left corner is at (0, 0),
    not at (1, 1).
    Programming languages derived from C (which includes C++, Java, Python, Perl, and Ruby)
    count from 0:
    the first five indices into anything are 0, 1, 2, 3, and 4.
    Some other languages (notably Fortran, MATLAB, and R) count from 1.
    The latter is more sensible&mdash;nobody says, "Zero, one, two, three, four," when counting their fingers&mdash;but
    we're stuck with the former for programming.
  </p>

  <p>
    The second thing to notice about this example is that a 10&times;10 image is hard to see,
    and a single white pixel is almost invisible.
    Let's try this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
<span class="highlight">block.inflation = 10</span>
block.show()
</pre>

  <p>
    An image's <code>inflation</code> property tells the library how large to make each pixel
    when displaying or saving the image.
    This doesn't change how many pixels there actually are,
    or how they're indexed;
    it's purely a convenience to help us see what we're doing.
  </p>

  <p>
    What if we want to make the upper-right pixel white instead?
    We happen to know that our image is 10&times;10,
    so we could do this:
  </p>

<pre>
block[9, 9] = (255, 255, 255)
</pre>

  <p class="continue">
    The upper-right index is (9, 9) because we're counting from 0:
    if the image is ten pixels across,
    its X coordinates are 0..9.
    This works in this specific case,
    but it's a bad long-term solution:
    if someone changes the size of the image,
    the upper-right pixel probably won't be at (9, 9) any longer,
    and we don't want to have to check our program line-by-line to find things like this.
  </p>

  <p>
    Here's one better solution:
  </p>

<pre>
block_width = 10
block_height = 10
block = novice.new((block_width, block_height), (255, 0, 0))
block[block_width - 1, block_height - 1] = (255, 255, 255)
</pre>

  <p>
    If someone changes the block's height or width now,
    the index expression in the last line will automatically adjust.
    This version of the program also makes the image's size a lot easier to find:
    instead of being buried inside a function call,
    <code>block</code>'s height and width are identified by name.
  </p>

  <p>
    We can improve this program even further like this:
  </p>

<pre>
block_width = 10
block_height = 10
<span class="highlight">red = (255, 0, 0)
white = (255, 255, 255)</span>
block = novice.new((block_width, block_height), <span class="highlight">red</span>)
block[block_width - 1, block_height - 1] = <span class="highlight">white</span>
</pre>

  <p class="continue">
    and then go one step further like this:
  </p>

<pre>
block_width = 10
block_height = 10
red = (255, 0, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), red)
block[<span class="highlight">-1, -1</span>] = white
</pre>

  <p>
    Unlike most languages,
    Python is happy with negative indices:
    it uses them to count backward from the ends of things,
    rather than forward from the start
    (<a href="#f:negative_indices">Figure XXX</a>).
    Once you get used to it,
    it makes programs much easier to read&mdash;as the examples above show,
    the <code>-1</code> can be easy to miss when it's tacked onto the end of a long expression.
  </p>

  <figure id="f:negative_indices">
    <img src="img/pymedia/negative_indices.png" alt="Negative Indices" />
  </figure>

  <p>
    Now,
    what if we want to put a white border around our image?
    We could do this:
  </p>

<pre>
block[0, 0] = white
block[0, 1] = white
block[0, 2] = white
...
block[0, 9] = white
</pre>

  <p class="continue">
    and then repeat it for the other three sides
    but that would be a lot of work to type in,
    we'd probably make mistakes along the way,
    and if the image size changes,
    we'll have to add or remove dozens or hundreds of lines.
    Here's a better way:
  </p>

<pre>
block[0, :]  = white
block[-1, :] = white
block[:, 0]  = white
block[:, -1] = white
</pre>

  <p>
    As you can probably guess,
    ':' on its own means "all indices"&mdash;it's a <a href="shell.html#pipefilter">wildcard</a>,
    just like '*' in filenames in the shell.
    Behind the scenes,
    the computer is still executing something like our original code&mdash;after all,
    each of the pixels on the border does need to be modified somehow&mdash;but:
  </p>

  <ol>
    <li>
      this code is much faster to write,
    </li>
    <li>
      much more likely to be correct,
      and
    </li>
    <li>
      once the computer knows it's supposed to update all the pixels in a row or column,
      it can probably do it faster than we could by hand.
    <li>
  </ol>

  <p>
    ':' on its own is actually a special case of something much more general
    called a <a href="glossary.html#slice">slice</a>.
    If we run this program:
  </p>

<pre>
from skimage import novice
block_width = 200
block_height = 200
green = (0, 255, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), green)
block[<span class="highlight">0:40, 0:40</span>] = white
</pre>

  <p class="continue">
    When we display this image,
    it is a single white tile in the lower-left of a green background
    (<a href="#f:single_tile">Figure XXX</a>):
  </p>

  <figure id="f:single_tile">
    <img src="img/pymedia/single_tile.png" alt="A Single Tile" />
  </figure>

  <p>
    You can probably guess that the expression <code>0:40</code> refers to
    a range of pixels:
    in this case, from index 0 to index 39 inclusive,
    i.e.,
    from the lower limit up to, but not including, the upper limit.
    It may seem strange not to include the upper limit,
    but it has several advantages:
  </p>

  <ol>
    <li>
      The number of values in <code>lower:upper</code> is <code>upper-lower</code>.
    </li>
    <li>
      When the ranges <code>lower:middle</code> and <code>middle:upper</code> are joined together,
      the pixel at coordinate <code>middle</code> is only included once.
    </li>
    <li>
      If the axis in question has <code>length</code> pixels,
      the expression <code>0:length</code> refers to each pixel exactly once.
    </li>
  </ol>

</section>

<section id="s:argv">

  <h2>Command-Line Arguments</h2>

  <div class="understand" id="u:argv">
    <h3>Understand:</h3>
    <ul>
      <li>How to work with command-line arguments.</li>
      <li>That slicing works in many places.</li>
    </ul>
  </div>

  <p>
    Let's go back to our thumbnail creation program for a moment.
    It would be much more useful if we could create a thumbnail of any image we wanted
    without having to edit the program each time to change the name of the file.
    What we want is something like this:
  </p>

<pre>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg</span>
$ <span class="in">python thumbnail mac.jpg</span>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg    thumb-mac.jpg</span>
</pre>

  <p>
    To make this work,
    we need a way to get filenames from the command line into our program.
    To do that,
    we need to use another library called <code>sys</code>
    (short for "system").
    It defines constants to tell us what version of Python we're using,
    what operating system we're running on,
    and so on:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">import sys</span>
&gt;&gt;&gt; <span class="in">print sys.version</span>
<span class="out">2.7 (r27:82525, Jul  4 2010, 09:01:59) [MSC v.1500 32 bit (Intel)]</span>
&gt;&gt;&gt; <span class="in">print sys.platform</span>
<span class="out">win32</span>
</pre>

  <p>
    The most commonly-used element of <code>sys</code>, though, is <code>sys.argv</code>,
    which holds the <a href="glossary.html#command-line-arguments">command-line arguments</a>
    used to run the program.
    These are accessed using indices,
    just like individual pixels;
    the biggest differences are that
    <code>sys.argv</code> is one-dimensional instead of two-dimensional,
    and that its values are strings rather than pixels.
    The name of the script itself is in <code>sys.argv[0]</code>;
    all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
    For example, here's a program that does nothing except
    print its first three command-line arguments:
  </p>

<pre>
import sys
print 'location 0:', sys.argv[0]
print 'location 1:', sys.argv[1]
print 'location 2:', sys.argv[2]
</pre>

  <p>
    If we run save this code in a file called <code>three.py</code>,
    and run it like this:
  </p>

<pre>
$ <span class="in">python three.py alpha beta</span>
</pre>

  <p class="continue">
    it prints:
  </p>

<pre>
<span class="out">location 0: three.py
location 1: alpha
location 2: beta</span>
</pre>

  <p>
    However,
    if we run it with no arguments,
    or only one,
    we get this:
  </p>

<pre>
$ <span class="in">python three.py</span>
<span class="out">location 0: /Users/gwilson/three.py
location 1:</span>
<span class="err">Traceback (most recent call last):
  File "/Users/gwilson/three.py", line 3, in &lt;module&gt;
    print 'location 1:', sys.argv[1]
IndexError: list index out of range</span>
</pre>

  <p>
    The problem is that <code>sys.argv[1]</code> doesn't exist,
    and Python won't let us read a value that isn't there.
    It's exactly like the undefined variables we encountered at the start of this chapter.
  </p>

  <p>
    Let's ignore that problem for now
    and go back to our thumbnail creator.
    Here's how we can make it work for an arbitrary file:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

filename = sys.argv[1]
picture = novice.open(filename)
new_height = picture.height * fixed_width / picture.width
picture.height = new_height
picture.width = fixed_width
picture.save('thumb-' + filename)
</pre>

  <p>
    Let's walk through it piece by piece:
  </p>

  <ul>
    <li>
      We start by importing the libraries we need.
      <code>import</code> statements can actually be anywhere in the program,
      but it's considered good style to put them at the top,
      as it makes it easy for people to see what the program depends on.
    </li>
    <li>
      We give the fixed width we want thumbnails to have a name,
      so that we don't have to scatter the number 30 throughout the program.
      Values that are meant to be constants are usually written in UPPER CASE;
      again,
      it's not a requirement,
      but it's what most people do,
      so by sticking to this convention you will make it easier for other people to understand your code.
    </li>
    <li>
      The name of the image to be thumbnailed is supposed to be the program's single command-line argument,
      which means it will be in <code>sys.argv[1]</code>.
      (Remember, the program's name is in <code>sys.argv[0]</code>.)
      We could just use <code>sys.argv[1]</code> everywhere,
      but assigning the value to the variable <code>filename</code> makes our program easier to follow.
    </li>
    <li>
      We calculate the picture's new size
      and resize the picture as before.
    </li>
    <li>
      Finally,
      we create the new filename by concatenating <code>'thumb-'</code> and the original filename,
      and save the thumbnail to that file.
    </li>
  </ul>

</section>

<section id="s:for">

  <h2>Repeating Things</h2>

  <div class="understand" id="u:for">
    <h3>Understand:</h3>
    <ul>
      <li>How to repeat things using a loop.</li>
      <li>That the loop variable takes on a different value each time through the loop.</li>
      <li>How to tell what statements are in the body of a loop.</li>
    </ul>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps.
    (After all,
    writing out a million additions would take longer than doing them.)
    Let's start by writing a program called <code>show.py</code>
    that displays its command-line arguments one by one:
  </p>

<pre>
import sys
for arg in sys.argv:
    print arg
</pre>

  <p>
    Here's what happens when we run it:
  </p>

<pre>
$ <span class="in">python show.py first second third</span>
<span class="out">show.py
first
second
third</span>
</pre>

  <p>
    The keywords <code>for</code> and <code>in</code> are used to create a <a href="glossary.html#for-loop">for loop</a>.
    Just like a <a href="shell.html#loop">loop in the shell</a>,
    a <code>for</code> loop in Python repeats one or more instructions
    for each value in some set.
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop:
    it's the command that Python executes repeatedly.
    The variable <code>arg</code> is sometimes called
    the <a href="glossary.html#loop-variable">loop variable</a>.
    There's nothing special about its name:
    we could equally well have called it <code>something</code>.
    What's important is that the <code>for</code> loop repeatedly
    assigns a value to it,
    then executes the loop body one more time.
  </p>

  <p>
    Python always uses indentation to show what's in the body of a loop
    (or anything else&mdash;we'll see other things that have bodies soon).
    This means that:
  </p>

<pre>
for arg in sys.argv:
    print arg
    print "all done"
</pre>

   <p class="continue">
     and:
   </p>

<pre>
for arg in sys.argv:
    print arg
print "all done"
</pre>

  <p class="continue">
    are different programs.
    The first one would print:
  </p>

<pre>
<span class="out">show.py
all done
first
all done
second
all done
third
all done</span>
</pre>

  <p class="continue">
    because the statement <code>print "all done"</code> is inside the loop body.
    The second is probably what we actually want,
    as it prints:
  </p>

<pre>
<span class="out">show.py
first
second
third
all done</span>
</pre>

  <p class="continue">
    because the final <code>print</code> is outside the loop.
  </p>

  <div class="box">

    <h3>Why Indentation?</h3>

    <p>
      Most other languages use visible markers to show the beginnings and ends of loop bodies,
      such as the <code>do</code> and <code>done</code> of the shell.
      Python uses indentation because studies done in the 1970s and 1980s showed
      that's what people actually pay attention to.
      If we write something as:
    </p>

<pre>
for value in data
do
    print value
print "done"
done
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as being outside the loop.
    </p>

  </div>

  <p>
    Let's go back and teach our thumbnail program how to process multiple files at once:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <p>
    Almost everything has stayed the same:
    the only change is that instead of assigning <code>sys.argv[1]</code> to <code>filename</code>,
    we're using a loop to assign it each value in <code>sys.argv</code> in turn.
    Let's try running it:
  </p>

<pre>
$ <span class="in">python thumbnail.py flower.jpg mac.jpg</span>
<span class="err">Traceback (most recent call last):
...several lines of error message...
IOError: cannot identify image file</span>
</pre>

  <p>
    Whoops:
    the first time through the loop,
    <code>filename</code> is assigned <code>sys.argv[0]</code>,
    which is the name of the Python program itself.
    The <code>novice.open</code> call then tries to open a Python program
    (i.e., a text file)
    as if it were an image.
    Unsurprisingly,
    that doesn't work.
  </p>

  <p>
    How can we fix this?
    By using a slice that starts at index 1
    and runs to the end of the list of filenames:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv<span class="in">[1:len(sys.argv)]</span>:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <p class="continue">
    Remember,
    a slice starts at its low index,
    and goes up to, but not including, its upper index.
    The expression <code>stuff[1:len(stuff)]</code> is therefore
    everything in <code>stuff</code> except the element at location zero
    (<a href="#f:all_but_the_first">Figure XXX</a>):
  </p>

  <figure id="f:all_but_the_first">
    <img src="img/pymedia/all_but_the_first.png" alt="All But The First Element" />
  </figure>

  <p>
    We can make this even simpler.
    If we don't specify the lower end of a slice,
    it defaults to 0,
    so <code>stuff[:3]</code> is elements 0, 1, and 2 of <code>stuff</code>.
    Similarly,
    if we don't specify the slice's upper end,
    it defaults to the end,
    so <code>stuff[3:]</code> is elements 3, 4, 5, and so on to the end.
    In particular,
    <code>stuff[1:]</code> is everything in <code>stuff</code> except the element at index 0,
    so we can rewrite our thumbnailer one more time as:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv<span class="in">[1:]</span>:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <div class="box">
    <h3>One Thing, Many Uses</h3>

    <p>
      Slices are a good example of a powerful idea in program design:
      if something works in one place,
      it ought to work everywhere.
      For example,
      if we want to select the first four characters from a string,
      you shouldn't be surprised that we do it like this:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">full_name = 'Alan Turing'</span>
&gt;&gt;&gt; <span class="in">first_name = full_name[:4]</span>
&gt;&gt;&gt; <span class="in">print first_name</span>
<span class="out">Alan</span>
</pre>

    <p class="continue">
      or that if we want to print each character from the string
      on a line of its own,
      we use:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">for char in 'Alan':
...     print char</span>
<span class="out">A
l
a
n</span>
</pre>

  </div>

  <p>
    Here's something else we can do with a loop:
  </p>

<pre>
from skimage import novice

picture = novice.open('mac.jpg')
picture.show()
for pixel in picture:
    pixel.red = pixel.red / 2
picture.show()
</pre>

  <p>
    <a href="#f:less_red">Figure XXX</a> shows the original and modified images side by side.
    The second version looks bluish-green
    because the amount of red in each pixel has been cut in half.
    That's what the <code>for</code> loop has done:
    each time through the loop,
    <code>pixel</code> has been assigned the next pixel in the image,
    and the statement:
  </p>

<pre>
    pixel.red = pixel.red / 2
</pre>

  <p class="continue">
    has half the original value of the pixel's <code>red</code> property
    and assigned it back to the pixel.
  </p>

  <figure id="f:less_red">
    <img src="img/pymedia/less_red.png" alt="Reducing the Red" />
  </figure>

  <p>
    What happens if we try to double the red instead?
  </p>

<pre>
&gt;&gt;&gt; <span class="in">picture = novice.open('mac.jpg')
&gt;&gt;&gt; for pixel in picture:
...    pixel.red = pixel.red * 2
...</span>
<span class="err">
Traceback (most recent call last):
...several lines of error message...
ValueError: Expected an integer between 0 and 255, but got 294 instead!</span>
</pre>

  <p class="continue">
    Just as Python won't let us use an index that's out of range,
    <code>skimage.novice</code> won't let us assign a color value
    that's out of the range from 0 to 255.
    If we want to make sure the value is in that range,
    we can do this instead:
  </p>

<pre>
picture = novice.open('mac.jpg')
for pixel in picture:
    pixel.red = min(255, pixel.red * 2)
</pre>

  <p>
    This works,
    and gives the result shown in <a href="#f:more_red">Figure XXX</a>.
  </p>

  <figure id="f:more_red">
    <img src="img/pymedia/more_red.png" alt="Increasing the Red" />
  </figure>

  <div class="keypoints" id="k:for">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>for <em>variable</em> in <em>something</em>:</code> to loop over the parts of something.</li>
      <li>The body of a loop must be indented consistently.</li>
      <li>The parts of a string are its characters; the parts of an image are its pixels.</li>
    </ul>
  </div>

</section>

{% endblock content %}
